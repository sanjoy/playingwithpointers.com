Haskell → Agda

As an amateur in both, I think Agda [1] is a good next step after
getting comfortable with Haskell [2], especially if the objective of
learning Haskell was to develop oneself as a programmer.  I hope this
article will pique the interest of people who get Haskell, and nudge
them a little bit towards Agda.

The Curry-Howard correspondence specifies a way to map types (in
simply typed lambda calculus) to propositions in constructive logic,
and values to proofs.  This is a fancy way of saying that given a
predicate ("x is less than five", say) it is possible to construct a
type (in simply typed lambda calculus) that has a value if and only if
the predicate is true.  Moreover, if we squint hard enough, we should
be able to show that this value somehow "proves" the predicate.  Since
Haskell is a superset of the simply typed lambda calculus, the
Curry-Howard correspondence applies to it, though somewhat crudely
[3].  Agda draws much of its power from the Curry-Howard
correspondence, as we'll see in a short while.

Haskell's type system splits the set of all things into values, types
and kinds (which are meta-types, or types of types).  Agda generalizes
this notion by having values, types of values, types of types of
values, types of types of types of values and so on.  More concretely,
Agda splits entities into objects, types at level 0, types at level 1
(meta-types), types at level 2 ... ad infinitum.  The typing relation
(that decides which type a value has) is a function from types at
level k to types at (k + 1), and from objects ("types" with no level)
to types at level 0.  This slightly complex arrangement is needed to
work around an important logical contradiction [4].  So, in Agda, 5 is
a value of type ℕ, and ℕ is a value of type Set₀ (also referred to as
Set), Set₀ is a value of type Set₁ and so on.  Agda has what I think
is best described as first-class types.  Functions can return types
just as easily as regular values; you can very well have a function
from "Maybe Char" to "arbitraryFunction x" where x is the first
argument passed to the function (a value of type "Maybe Char").  This
makes it possible to write a type-safe printf in Agda, one which
decides its type depending on the format string.  In other words, with
first-class types, it is possible to express arbitrary contracts or
invariants in the type system and have the compiler check them for us.

I mentioned that Haskell respects the CH correspondence only crudely.
The crudeness comes from the fact that Haskell admits ⊥ (denoted as
undefined inside Haskell programs) as a value, denote non-termination
and error conditions.  ⊥ (called bottom) pokes a hole in the type
system since every type (in Haskell) in inhabited by ⊥.  Given a type
T, it is always possible to produce a Haskell value of the type:
"undefined :: T" is one way, "let x = x in x :: T" is another.  This
is problematic -- the logical statement corresponding to "all types
are inhabited" is "all predicates are provable"!

Agda doesn't have ⊥ and hence avoids the above issue.  Unfortunately,
this also implies that Agda isn't Turing complete, not every algorithm
can be implemented in Agda.

[[ Introduce Dependent Types ]]

[[ Coinductive data structures, co-recursion ]]

[1]: http://en.wikipedia.org/wiki/Agda_(programming_language)
[2]: http://en.wikipedia.org/wiki/Haskell_(programming_language)
[3]: http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism
[4]: http://en.wikipedia.org/wiki/Russell's_paradox
