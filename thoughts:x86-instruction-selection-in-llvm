x86 Instruction Selection in llvm

I've been poking around llvm's [1] instruction selector and scheduler;
and have decided to write a few short notes to help myself understand
them better and to perhaps serve as a guidepost to others trying to do
the same.  This one is about llvm's instruction selector.  I will only
talk about x86, but it is likely that this partially carries over to
other architectures.

Like almost everything in llvm, the instruction selector is modeled as
a pass (specifically, a `MachineFunctionPass`).  Each target registers
its own instruction selector, and in the case of x86, this happens in
`X86TargetMachine.cpp`:

    bool X86PassConfig::addInstSelector() {
      // ...
      addPass(createX86ISelDag(getX86TargetMachine(), getOptLevel()));
      // ...
    }

The pass itself resides in `X86ISelDAGToDAG.cpp` as the
`X86DAGToDAGISel` class.  A non-trivial chunk of the action, however,
is in its parent `SelectionDAGISel` -- llvm tries hard to have as many
things architecture-independent as possible.

Instead of directly encoding repetitive architecture specific
information in C++, llvm stores such data in `\*.td` files.  During
_build time_, such information is read out using *`tablegen`* [2] and
emitted as source code that is then compiled along with the rest of
llvm.  This method gives llvm the flexibility of encoding domain
specific information succinctly without sacrificing performance.  For
the situation at hand, llvm uses the `tablegen` infrastructure to
implement a code-generator-generator [3].  The patterns and the
machine code they correspond to is stored in the various
`lib/Target/X86/X86Instr\*.td` files; this is read in by tablegen (a
program _using_ the tablegen library, rather) and converted into a C++
instruction selector.

The instruction selector modelled as an interpreter (call it a state
machine if you like) with an architecture specific _program_ (just an
array of opcodes) generated by `tablegen`.  The interpreter itself is
platform independent, and most of it is contained in
`SelectionDAGISel.cpp` as `SelectCodeCommon`.  Its entry point is
`X86DAGToDAGISel::SelectCode`, the body of which is generated into
`X86GenDAGISel.inc` by `tablegen` and `#include`d in the middle of the
class `X86DAGToDAGISel`.  For x86, it simply calls into
`SelectCodeCommon` passing in the opcode array. Opcodes for the state
machine are documented in `DAGISelMatcher.h`, they are subclasses of
`Matcher`.  `MatcherGen` (in `DAGISelMatcherGen.cpp`) converts the
tree patterns read in from the `\*.td` files and
`DAGISelMatcherEmitter.cpp` emits these `Matcher`s into the C++ source
file that gets compiled in with llvm.  In `MatcherGen`,
`EmitMatchCode` emits a `Matcher` that does a structural match on a
tree pattern, for instance.  At the top level, `DAGISelEmitter::run`
(in `DAGISelEmitter.cpp`), reads in all the patterns, sorts them
according to a cost heuristic, optimizes the `Matcher` tree and emits
them into a source file.

[1]: http://llvm.org
[2]: http://llvm.org/docs/TableGenFundamentals.html
[3]: Ch. 6, Advanced Compiler Design & Implementation, Muchnick.
